---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

## Overview

The TidyABS package converts ABS excel sheets into a tidy dataframes. It can often guess the structure of the excel table using heuristics and tidy without any hints from the user, however sometimes pointers are necessary. 

_Note: tidyABS works with .xlsx files only. ABS files are often in .xls format, so conversion is required._

## Installation

TidyABS is not available on CRAN. The package can be installed from github with the following script:
 
```{r eval = FALSE}
# install.packages("devtools")
devtools::install_github("ianmoran11/tidyABS")
```

## Usage

```{r include = FALSE}
options(tibble.print_min = 3, tibble.print_max = 3)
library(magick)
```

```{r message=FALSE, warning=FALSE}
library(tidyABS)
library(tidyverse)
```


Below is a quick demonstration that tidies an Australian Industry sheet. 

```{r message=FALSE, warning=FALSE}
tidyABS_example("australian-industry.xlsx") %>% 
  process_ABS_sheet(sheets = "Table_1") %>% 
  assemble_table_components()  %>% 
  glimpse
  
```

More functionality of the tidyABS is presented below.

### Example 1: Australian Industry

```{r echo=FALSE, message=FALSE, warning=FALSE}
magick::image_read( "australian-industry_table-1.png")
```

tidyABS includes several example files. Use the helper `tidyABS_example()` with no arguments to list these files:

```{r message=FALSE, warning=FALSE}
tidyABS_example()
```

Here's the first sheet of an excel workbook from the Australian  Industry publication. We can retrieve the path of this file  using the `tidyABS_example` function with our filename as the argument:

```{r message=FALSE, warning=FALSE}
ai_path <- tidyABS_example("australian-industry.xlsx")
```

We can now process `Table_1` (the first sheet of the workbook) using the `process_ABS_sheet` function.

```{r message=FALSE, warning=FALSE}
ai_processed <-  process_ABS_sheet(path = ai_path, sheets = "Table_1") 

ai_processed %>% str(1)
```

As you can see `ai_processed` is a list of three dataframes. It stores the location and format information of row names (`row_groups`) and column names (`col_groups`) inner cell values of the table (`tabledata`).  

We can inspect `ai_processed` to see what values have been classified as row and column cells using the `inspect_table_components` function.


```{r message=FALSE, warning=FALSE}
inspect_table_components(ai_processed)
```

We can also  can visually inspect how these groups are spatially layed out in the spreadsheet any how tidyABS will relate them to table values with `plot_table_components`.

```{r fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
plot_table_components(ai_processed) + 
  ylim(-30,0) 
```

Finally, we can assembly the components into a tidy dataframe using `assemble_table_components`.

```{r message=FALSE, warning=FALSE}
assemble_table_components(ai_processed) %>% 
  glimpse
```

All that is left to do is to rename columns are convert values to the appropriate data types. 

### Example 2: Environmental-Economic Accounts

```{r echo=FALSE, message=FALSE, warning=FALSE}
magick::image_read("environmental-economic-accounts_table-6-01.png")
```

Here's an example that requires some manual work, the Environmental Economic Accounts. Let's retrieve the path of our example file and proces it:

```{r message=FALSE, warning=FALSE}
eea_path <- tidyABS_example("environmental-economic-accounts.xlsx")

eea_processed <- process_ABS_sheet(path = eea_path, sheets = "Table 6.1")
```

On visual inspection, We can see `row_group_01` has been given a "W" orientation to the data, not "WNW". 

```{r fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
plot_table_components(eea_processed)
```

Luckily, we can fix this with the `change_direction` function. 

```{r message=FALSE, warning=FALSE}
eea_processed <- 
  eea_processed %>% 
  change_direction("row_group_01","WNW")
```

Plotting the table confirms the direction has been corrected. 

```{r fig.height=6, fig.width=10, message=FALSE, warning=FALSE}
plot_table_components(eea_processed)
```

Finally, we can assembly the components into a tidy dataframe using `assemble_table_components`.

```{r message=FALSE, warning=FALSE}
assemble_table_components(eea_processed)   %>% 
  glimpse
```

### Example 3: Consumer Price Index (time series)

```{r echo=FALSE, message=FALSE, warning=FALSE}
magick::image_read("consumer-price-index_data01.png")
```

Time series data require the user to manually identify the inner table cells. This is because some of the column groups are entered as numbers --- for example, collection month. 

I recommend using the [`readABS`](https://github.com/MattCowgill/readabs) package. This package was built for importing ABS time series data and does not require any manual identifcation of table cells. 

That said, here's how you would do this with `tidyABS`.

```{r message=FALSE, warning=FALSE}
cpi_path <- tidyABS_example("consumer-price-index.xlsx")
```

We need to identify the inner table cells using the `manual_value_references` argument to `process_ABS_sheet`.This arguments takes a vectors addresses, identifying the inner corners of the table. 

```{r message=FALSE, warning=FALSE}
cpi_processed <- 
  process_ABS_sheet(path = cpi_path, sheets = "Data1",
                    manual_value_references = c("B11","AB11","B292","AB292"))
```

And here is the resulting data frame. 

```{r message=FALSE, warning=FALSE}
assemble_table_components(cpi_processed)   %>% 
  glimpse
```
