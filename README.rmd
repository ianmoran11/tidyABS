---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```


## Overview

The TidyABS package converts ABS excel sheets into a tidy dataframes. It can often guess the structure of the excel table using heuristics and tidy without any hints from the user, however sometimes pointers are necessary. 

_Note: tidyABS works with .xlsx files only. ABS files are often in .xls format, so conversion is required._


## Installation

TidyABS is not available on CRAN. The package can be installed from github with the following script:
 
```{r eval = FALSE}
# install.packages("devtools")
devtools::install_github("ianmoran11/tidyABS")
```

## Usage

```{r include = FALSE}
options(tibble.print_min = 3, tibble.print_max = 3)
```

```{r message=FALSE, warning=FALSE}
library(tidyABS)
library(tidyverse)
```

tidyABS includes several example files. Use the helper `tidyABS_example()` with no arguments to list these files:

```{r message=FALSE, warning=FALSE}
tidyABS_example()
```

### Example 1: Australian Industry

Here's an excel workbook from the Australian  Industry publication. We retrieve the path of this file  using the `tidyABS_example` function with our filename as the argument:

```{r message=FALSE, warning=FALSE}
ai_path <- tidyABS_example("australian-industry.xlsx")
```

We can now process "Table_1" (the first sheet of the workbook) using the `process_ABS_sheet` function.

```{r message=FALSE, warning=FALSE}
ai_01_processed <-  process_ABS_sheet(path = ai_path, sheets = "Table_1") 

ai_01_processed %>% str(1)
```

As you can see `mvu_01_processed` is a list of three dataframes. It stores the location and format information of row names (`row_groups`) and column names (`col_groups`) inner cell values of the table (`tabledata`).  

We can inspect `mvu_01_processed` to see what values have been classified as row and column cells using the `inspect_table_components` function.


```{r message=FALSE, warning=FALSE}
inspect_table_components(ai_01_processed)
```

As you can see:  
* `col_group1` represents the measure associated with the value in the table  
* `col_group2` represents the units of value in the table  
* `row_group1` represents the year associated with the value in the table  
* `row_group2` industry associated with value in the table. 

We can also  can visually inspect how these groups are spatially layed out in the spreadsheet any how tidyABS will relate them to table values with `plot_table_components`.

```{r fig.height=8, fig.width=16, message=FALSE, warning=FALSE}
plot_table_components(ai_01_processed) + 
  ylim(-30,0) + xlim(0,5)
```


Finally, we can assembly the components into a tidy dataframe using `assemble_table_components`.

```{r message=FALSE, warning=FALSE}
assemble_table_components(ai_01_processed) %>% 
  glimpse
```

All that is left to do is to rename columns are convert values to the appropriate data types. Too easy!

### Example 2: Environmental-Economic Accounts

Unfortunately it is not always easy. 

Here's an example proccess data from the Environmental Economic Accounts. First, lets retrieve the path of our example file:

```{r message=FALSE, warning=FALSE}
eea_path <- tidyABS_example("environmental-economic-accounts.xlsx")
```

Then sheet 1 ("Table 6.1") of that file using the function `process_ABS_sheet`

```{r message=FALSE, warning=FALSE}
eea_01_processed <- process_ABS_sheet(path = eea_path, sheets = "Table 6.1")
```

On visual inspection, We can see some `row_group_01` has been given a "W" orientation to the data, not "WNW". 

```{r fig.height=8, fig.width=16, message=FALSE, warning=FALSE}
plot_table_components(eea_01_processed)
```


Luckily, we can fix this with the `change_direction` function. 

```{r message=FALSE, warning=FALSE}
eea_01_processed <- 
  eea_01_processed %>% 
  change_direction("row_group_01","WNW")
```

Plotting the table shows that it as been corrected. 

```{r fig.height=8, fig.width=16, message=FALSE, warning=FALSE}
plot_table_components(eea_01_processed)
```

Finally, we can assembly the components into a tidy dataframe using `assemble_table_components`.

```{r message=FALSE, warning=FALSE}
assemble_table_components(eea_01_processed)   %>% 
  glimpse
```


### Example 3: Consumer Price Index (time series)

Time series data require the user to manually identify the inner table cells. This is because some of the column groups are entered as numbers --- for example, collection month. 

I recommend using the [`readABS`](https://github.com/MattCowgill/readabs) package. This package was built for process ABS time series data and does not require any manual identifcation of table cells. 

That said, here's how you would do this with `tidyABS`.

```{r message=FALSE, warning=FALSE}
cpi_path <- tidyABS_example("consumer-price-index.xlsx")
```

We need to identify the inner table cells using the `manual_value_references` argument to `process_ABS_sheet`.This arguments takes a vectors addresses, identifying the inner corners of the table. 

```{r message=FALSE, warning=FALSE}
cpi_processed <- 
  process_ABS_sheet(path = cpi_path, sheets = "Data1",
                    manual_value_references = c("B11","AB11","B292","AB292"))
```

And here is the resulting data frame. 

```{r message=FALSE, warning=FALSE}
assemble_table_components(cpi_processed)   %>% 
  glimpse
```
