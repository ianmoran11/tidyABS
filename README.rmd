---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```


## Overview

The TidyABS package converts excel sheets released by the Australian Bureau of Statistics into a tidy data format.    

Note: Files must be saved as .xlsx files. 


## Installation

TidyABS is not available on CRAN. The package can be installed from github with the following script:
 
```{r eval = FALSE}
# install.packages("devtools")
devtools::install_github("ianmoran11/tidyABS")
```

## Usage

```{r include = FALSE}
options(tibble.print_min = 3, tibble.print_max = 3)
```

```{r}
library(tidyABS)
```

tidyABS includes several example files.  Use the helper `tidyABS_example()` with no arguments to list them or call it with an example filename to get the path.

```{r}

tidyABS_example()

```

### Example 1: Environmental-Economic Accounts

Here's an example proccess data from the Employee Earnings and Hours release. First retriev the path of our example file:

```{r}

eea_path <- tidyABS_example("environmental-economic-accounts.xlsx")

```

We can now process Sheet 1 of that file using the function `process_ABS_sheet`


```{r}

eea_01_processed <- process_ABS_sheet(path = eea_path, sheets = "Table 6.1")

print(eea_01_processed)

```

`mvu_01_processed` is a list of three dataframes. It stores the location and formation information of the cells that have been indentified as row names (`row_groups`) and column names (`col_groups`). It also contains the data values inside the data (`tabledata`).  

We can inspect what values have been allocated to which groups using the `inspect_table_components`. Each group will be given its own column in the resulting tidy dataframe.


```{r}
inspect_table_components(eea_01_processed)

```


We can alph inspect classification of cells visually using 



```{r}
eea_01_plot <- plot_table_components(eea_01_processed)

# Just look at the first rows 
eea_01_plot + ylim(-20,-1)

```

Finally, we can assembly the components into a tidy dataframe using `assemble_table_components`.

```{r}
assemble_table_components(eea_01_processed) 

```

With a little extra processing, we can plot this time series.

```{r}
assemble_table_components(eea_01_processed) %>% View
  set_names(c("row", "col", "comment", "value", "year", "tax_01", 
"total", "total")) %>% 
  mutate(value = as.numeric(value)) %>% 
  mutate(year =  as.numeric(str_extract(year,"[0-9]{4}")))

```


### Example 2: Australian Industry

Here's an example proccess data from the Employee Earnings and Hours release. First retriev the path of our example file:

```{r}

tidyABS_example()

ai_path <- tidyABS_example("australian-industry.xlsx")

```

We can now process Sheet 1 of that file using the function `process_ABS_sheet`


```{r}

ai_01_processed <- process_ABS_sheet(path = ai_path, sheets = "Table_1")


```

`mvu_01_processed` is a list of three dataframes. It stores the location and formation information of the cells that have been indentified as row names (`row_groups`) and column names (`col_groups`). It also contains the data values inside the data (`tabledata`).  

We can inspect what values have been allocated to which groups using the `inspect_table_components`. Each group will be given its own column in the resulting tidy dataframe.


```{r}
inspect_table_components(ai_01_processed)

```


We can alph inspect classification of cells visually using 



```{r}
eea_01_plot <- plot_table_components(eea_01_processed)

# Just look at the first rows 
eea_01_plot + ylim(-20,-1)

```

Finally, we can assembly the components into a tidy dataframe using `assemble_table_components`.

```{r}
assemble_table_components(eea_01_processed) 

```

With a little extra processing, we can plot this time series.

```{r}
assemble_table_components(eea_01_processed) %>% View
  set_names(c("row", "col", "comment", "value", "year", "tax_01", 
"total", "total")) %>% 
  mutate(value = as.numeric(value)) %>% 
  mutate(year =  as.numeric(str_extract(year,"[0-9]{4}")))

```
